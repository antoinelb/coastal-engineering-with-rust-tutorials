# Tutorial 4.1: Wave Climate Analysis for BC Coast
## Global Wave Environments Chapter 4.1-4.3

### Learning Objectives
By the end of this tutorial, you will:
1. Understand how global wind patterns create distinct wave climates
2. Analyze long-term wave data to characterize regional wave environments
3. Implement wave climate analysis tools for the BC coast using Rust
4. Identify seasonal patterns and extreme events in wave data
5. Connect wave climates to coastal morphology and engineering applications

### Prerequisites
- Read Coastal Dynamics Ch. 4.1-4.3
- Understanding of wave statistics from Tutorial 3.1
- Basic knowledge of atmospheric and oceanic circulation
- Rust development environment with data processing capabilities

### Introduction: Why Wave Climate Matters

Understanding wave climate is fundamental to coastal engineering and environmental management. The BC coast experiences one of the world's most energetic wave climates, with significant implications for:
- **Coastal erosion**: High-energy winter storms shape beaches and cliffs
- **Port operations**: Wave climate determines operational windows
- **Marine renewable energy**: Wave power potential assessment
- **Ecological habitats**: Wave exposure influences intertidal communities
- **Indigenous coastal use**: Traditional harvesting areas depend on wave conditions

MarineLabs' sensor networks provide real-time wave data that, when combined with historical records, reveal patterns critical for climate adaptation and sustainable coastal development.

### Part 1: Global Context of BC Wave Climate

#### Wave Generation and Propagation

The BC coast receives waves from multiple sources:
1. **Local wind seas**: Generated by regional weather systems
2. **North Pacific swell**: From storms in the Gulf of Alaska
3. **Southern Ocean swell**: Long-period waves from the Southern Hemisphere

**Key Concepts:**
- **Fetch**: Distance over which wind acts on the water surface
- **Duration**: Time period of sustained wind
- **Wave age**: Ratio of wave speed to wind speed ($c/U$)
- **Great circle propagation**: Swell travels along shortest paths on Earth's sphere

The North Pacific is one of the most consistent wave generators globally due to:
- Strong westerly winds (40-60°N latitude)
- Large fetch across the Pacific basin
- Frequent extratropical cyclones

#### Questions to Consider
1. How does the Coriolis effect influence storm tracks and resulting wave climates?
2. Why does the BC coast experience larger waves in winter than summer?
3. How might climate change affect North Pacific storm patterns and wave climates?

### Part 2: Data Structures for Wave Climate Analysis

Let's build a comprehensive wave climate analysis system. Create `src/wave_climate.rs`:

```rust
// wave_climate.rs
use chrono::{DateTime, Datelike, Utc};
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// Wave observation with directional information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaveObservation {
    pub timestamp: DateTime<Utc>,
    pub hs: f64,                    // Significant wave height (m)
    pub tp: f64,                    // Peak period (s)
    pub tm: f64,                    // Mean period (s)
    pub dp: f64,                    // Peak direction (degrees from North)
    pub dm: f64,                    // Mean direction (degrees from North)
    pub spread: f64,                // Directional spread (degrees)
    pub wind_speed: Option<f64>,    // Wind speed (m/s)
    pub wind_dir: Option<f64>,      // Wind direction (degrees)
}

/// Wave climate statistics for a given period
#[derive(Debug, Clone)]
pub struct WaveClimateStats {
    pub mean_hs: f64,
    pub max_hs: f64,
    pub percentiles: HashMap<u8, f64>,  // e.g., 50th, 90th, 99th percentile
    pub mean_tp: f64,
    pub dominant_direction: f64,
    pub directional_spread: f64,
    pub storm_count: usize,             // Number of storms (Hs > threshold)
    pub calm_percentage: f64,           // Percentage of time Hs < calm threshold
}

/// Seasonal wave climate analysis
pub struct SeasonalAnalysis {
    pub winter: WaveClimateStats,      // Dec, Jan, Feb
    pub spring: WaveClimateStats,      // Mar, Apr, May
    pub summer: WaveClimateStats,      // Jun, Jul, Aug
    pub fall: WaveClimateStats,        // Sep, Oct, Nov
}

/// Wave climate analyzer
pub struct WaveClimateAnalyzer {
    observations: Vec<WaveObservation>,
    location: String,
    storm_threshold: f64,  // Hs threshold for storm conditions
    calm_threshold: f64,   // Hs threshold for calm conditions
}

impl WaveClimateAnalyzer {
    /// Create new analyzer with data
    pub fn new(location: String, storm_threshold: f64, calm_threshold: f64) -> Self {
        WaveClimateAnalyzer {
            observations: Vec::new(),
            location,
            storm_threshold,
            calm_threshold,
        }
    }
    
    /// Add observations to the dataset
    pub fn add_observations(&mut self, mut obs: Vec<WaveObservation>) {
        self.observations.append(&mut obs);
        self.observations.sort_by_key(|o| o.timestamp);
    }
    
    /// Calculate basic statistics for a subset of observations
    fn calculate_stats(&self, subset: &[WaveObservation]) -> WaveClimateStats {
        if subset.is_empty() {
            panic!("Cannot calculate statistics for empty dataset");
        }
        
        // Extract Hs values and sort for percentiles
        let mut hs_values: Vec<f64> = subset.iter().map(|o| o.hs).collect();
        hs_values.sort_by(|a, b| a.partial_cmp(b).unwrap());
        
        // Calculate percentiles
        let mut percentiles = HashMap::new();
        for p in &[50, 90, 95, 99] {
            let idx = ((*p as f64 / 100.0) * (hs_values.len() - 1) as f64) as usize;
            percentiles.insert(*p, hs_values[idx]);
        }
        
        // Mean values
        let mean_hs = hs_values.iter().sum::<f64>() / hs_values.len() as f64;
        let max_hs = *hs_values.last().unwrap();
        let mean_tp = subset.iter().map(|o| o.tp).sum::<f64>() / subset.len() as f64;
        
        // Dominant direction (vector averaging)
        let (sin_sum, cos_sum) = subset.iter()
            .fold((0.0, 0.0), |(sin_acc, cos_acc), obs| {
                let rad = obs.dp.to_radians();
                (sin_acc + rad.sin(), cos_acc + rad.cos())
            });
        let dominant_direction = sin_sum.atan2(cos_sum).to_degrees();
        let dominant_direction = if dominant_direction < 0.0 { 
            dominant_direction + 360.0 
        } else { 
            dominant_direction 
        };
        
        // Storm and calm statistics
        let storm_count = subset.iter().filter(|o| o.hs > self.storm_threshold).count();
        let calm_count = subset.iter().filter(|o| o.hs < self.calm_threshold).count();
        let calm_percentage = (calm_count as f64 / subset.len() as f64) * 100.0;
        
        // Average directional spread
        let directional_spread = subset.iter().map(|o| o.spread).sum::<f64>() / subset.len() as f64;
        
        WaveClimateStats {
            mean_hs,
            max_hs,
            percentiles,
            mean_tp,
            dominant_direction,
            directional_spread,
            storm_count,
            calm_percentage,
        }
    }
    
    /// Perform seasonal analysis
    pub fn seasonal_analysis(&self) -> SeasonalAnalysis {
        // Group observations by season
        let mut winter = Vec::new();
        let mut spring = Vec::new();
        let mut summer = Vec::new();
        let mut fall = Vec::new();
        
        for obs in &self.observations {
            match obs.timestamp.month() {
                12 | 1 | 2 => winter.push(obs.clone()),
                3 | 4 | 5 => spring.push(obs.clone()),
                6 | 7 | 8 => summer.push(obs.clone()),
                9 | 10 | 11 => fall.push(obs.clone()),
                _ => unreachable!(),
            }
        }
        
        SeasonalAnalysis {
            winter: self.calculate_stats(&winter),
            spring: self.calculate_stats(&spring),
            summer: self.calculate_stats(&summer),
            fall: self.calculate_stats(&fall),
        }
    }
}
```

### Part 3: Wave Rose and Directional Analysis

Understanding wave directionality is crucial for BC coastal engineering:

```rust
// In wave_climate.rs
use std::f64::consts::PI;

/// Directional bin for wave rose
#[derive(Debug, Clone)]
pub struct DirectionalBin {
    pub direction: f64,      // Center direction (degrees)
    pub width: f64,          // Bin width (degrees)
    pub hs_mean: f64,        // Mean Hs in this direction
    pub occurrence: f64,     // Percentage of time
    pub energy_fraction: f64, // Fraction of total wave energy
}

impl WaveClimateAnalyzer {
    /// Create wave rose data
    pub fn wave_rose(&self, n_bins: usize) -> Vec<DirectionalBin> {
        let bin_width = 360.0 / n_bins as f64;
        let mut bins = vec![Vec::new(); n_bins];
        
        // Sort observations into directional bins
        for obs in &self.observations {
            let mut dir = obs.dp;
            if dir < 0.0 { dir += 360.0; }
            if dir >= 360.0 { dir -= 360.0; }
            
            let bin_idx = ((dir / bin_width) as usize) % n_bins;
            bins[bin_idx].push(obs);
        }
        
        // Calculate statistics for each bin
        let total_energy: f64 = self.observations.iter()
            .map(|o| o.hs.powi(2))  // Wave energy ∝ H²
            .sum();
        
        bins.into_iter().enumerate().map(|(i, obs_vec)| {
            let direction = i as f64 * bin_width + bin_width / 2.0;
            
            if obs_vec.is_empty() {
                DirectionalBin {
                    direction,
                    width: bin_width,
                    hs_mean: 0.0,
                    occurrence: 0.0,
                    energy_fraction: 0.0,
                }
            } else {
                let hs_mean = obs_vec.iter().map(|o| o.hs).sum::<f64>() / obs_vec.len() as f64;
                let occurrence = (obs_vec.len() as f64 / self.observations.len() as f64) * 100.0;
                let bin_energy: f64 = obs_vec.iter().map(|o| o.hs.powi(2)).sum();
                let energy_fraction = bin_energy / total_energy;
                
                DirectionalBin {
                    direction,
                    width: bin_width,
                    hs_mean,
                    occurrence,
                    energy_fraction,
                }
            }
        }).collect()
    }
    
    /// Identify swell vs wind sea components
    pub fn classify_wave_systems(&self) -> (Vec<WaveObservation>, Vec<WaveObservation>) {
        let mut swell = Vec::new();
        let mut wind_sea = Vec::new();
        
        for obs in &self.observations {
            // Use wave age criterion: swell if Tp > 1.2 * (wind period)
            // Approximate wind period from wind speed: Tw ≈ 0.33 * U (deep water)
            if let Some(wind_speed) = obs.wind_speed {
                let wind_period = 0.33 * wind_speed;
                let wave_age = obs.tp / wind_period;
                
                if wave_age > 1.2 {
                    swell.push(obs.clone());
                } else {
                    wind_sea.push(obs.clone());
                }
            } else {
                // Without wind data, use period threshold
                // Typical BC coast: swell if Tp > 10s
                if obs.tp > 10.0 {
                    swell.push(obs.clone());
                } else {
                    wind_sea.push(obs.clone());
                }
            }
        }
        
        (swell, wind_sea)
    }
}
```

### Part 4: Extreme Value Analysis

For engineering design, we need to estimate extreme wave conditions:

```rust
// In src/extreme_analysis.rs
use statrs::distribution::{ContinuousCDF, Weibull};
use ndarray::{Array1, Array2};

/// Extreme value analysis for wave heights
pub struct ExtremeValueAnalysis {
    annual_maxima: Vec<f64>,
    threshold: f64,  // For POT analysis
}

impl ExtremeValueAnalysis {
    /// Fit Generalized Extreme Value (GEV) distribution
    pub fn fit_gev(&self) -> GevParameters {
        // Simplified GEV fitting using method of moments
        let data = Array1::from_vec(self.annual_maxima.clone());
        let mean = data.mean().unwrap();
        let std = data.std(0.0);
        
        // Initial estimates (simplified)
        let shape = -0.1;  // Typical for wave heights
        let scale = std * 0.78;  // Approximation
        let location = mean - scale * 0.577;  // Euler's constant
        
        GevParameters { location, scale, shape }
    }
    
    /// Estimate return values
    pub fn return_value(&self, return_period: f64, params: &GevParameters) -> f64 {
        let p = 1.0 - 1.0 / return_period;
        
        if params.shape.abs() < 1e-10 {
            // Gumbel distribution (shape ≈ 0)
            params.location - params.scale * (-(-p.ln()).ln())
        } else {
            // General GEV
            params.location + params.scale / params.shape * 
                (1.0 - (-p.ln()).powf(-params.shape))
        }
    }
    
    /// Peak-over-threshold analysis
    pub fn pot_analysis(&self, observations: &[WaveObservation]) -> PotResults {
        let exceedances: Vec<f64> = observations.iter()
            .filter_map(|o| if o.hs > self.threshold { Some(o.hs - self.threshold) } else { None })
            .collect();
        
        let n_years = observations.len() as f64 / (365.25 * 24.0 / 3.0);  // Assuming 3-hour data
        let rate = exceedances.len() as f64 / n_years;
        
        // Fit exponential distribution to exceedances (simplified GPD with shape=0)
        let mean_excess = exceedances.iter().sum::<f64>() / exceedances.len() as f64;
        
        PotResults {
            threshold: self.threshold,
            rate_per_year: rate,
            scale: mean_excess,
            n_exceedances: exceedances.len(),
        }
    }
}

#[derive(Debug)]
pub struct GevParameters {
    pub location: f64,  // μ
    pub scale: f64,     // σ
    pub shape: f64,     // ξ
}

#[derive(Debug)]
pub struct PotResults {
    pub threshold: f64,
    pub rate_per_year: f64,
    pub scale: f64,
    pub n_exceedances: usize,
}
```

### Part 5: Visualization and Reporting

Create comprehensive visualizations for wave climate:

```rust
// In src/visualization.rs
use plotters::prelude::*;
use crate::wave_climate::{WaveClimateAnalyzer, DirectionalBin};

pub fn plot_wave_rose(
    bins: &[DirectionalBin],
    output_path: &str,
    title: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new(output_path, (800, 800)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let max_radius = bins.iter()
        .map(|b| b.hs_mean * b.occurrence / 100.0)
        .fold(0.0, f64::max) * 1.2;
    
    let mut chart = ChartBuilder::on(&root)
        .caption(title, ("sans-serif", 40))
        .margin(20)
        .build_cartesian_2d(-max_radius..max_radius, -max_radius..max_radius)?;
    
    // Draw directional bins
    for bin in bins {
        let theta = (90.0 - bin.direction).to_radians();  // Convert from compass to math angles
        let r = bin.hs_mean * bin.occurrence / 100.0;
        
        // Create wedge polygon
        let n_points = 20;
        let dtheta = bin.width.to_radians() / n_points as f64;
        let start_theta = theta - bin.width.to_radians() / 2.0;
        
        let mut points = vec![(0.0, 0.0)];
        for i in 0..=n_points {
            let angle = start_theta + i as f64 * dtheta;
            points.push((r * angle.cos(), r * angle.sin()));
        }
        
        // Color based on mean Hs
        let color = match bin.hs_mean {
            h if h < 1.0 => BLUE.mix(0.3),
            h if h < 2.0 => BLUE.mix(0.5),
            h if h < 3.0 => YELLOW.mix(0.7),
            h if h < 4.0 => ORANGE.mix(0.7),
            _ => RED.mix(0.7),
        };
        
        chart.draw_series(std::iter::once(Polygon::new(points, color)))?;
    }
    
    // Add compass directions
    let directions = vec![("N", 0.0), ("E", 90.0), ("S", 180.0), ("W", 270.0)];
    for (label, deg) in directions {
        let theta = (90.0 - deg).to_radians();
        let x = max_radius * 0.9 * theta.cos();
        let y = max_radius * 0.9 * theta.sin();
        
        chart.draw_series(std::iter::once(Text::new(
            label,
            (x, y),
            ("sans-serif", 20).into_font(),
        )))?;
    }
    
    root.present()?;
    Ok(())
}

pub fn plot_seasonal_comparison(
    analyzer: &WaveClimateAnalyzer,
    output_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let seasonal = analyzer.seasonal_analysis();
    let root = BitMapBackend::new(output_path, (1200, 800)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let mut chart = ChartBuilder::on(&root)
        .caption("Seasonal Wave Climate - BC Coast", ("sans-serif", 30))
        .margin(10)
        .x_label_area_size(30)
        .y_label_area_size(40)
        .build_cartesian_2d(
            ["Winter", "Spring", "Summer", "Fall"].as_ref(),
            0.0..6.0,
        )?;
    
    chart.configure_mesh()
        .y_desc("Significant Wave Height (m)")
        .x_desc("Season")
        .draw()?;
    
    // Plot mean and percentiles
    let seasons = vec![
        ("Winter", &seasonal.winter),
        ("Spring", &seasonal.spring),
        ("Summer", &seasonal.summer),
        ("Fall", &seasonal.fall),
    ];
    
    // Mean values
    chart.draw_series(
        seasons.iter().map(|(name, stats)| {
            Rectangle::new([(*name, 0.0), (*name, stats.mean_hs)], BLUE.filled())
        })
    )?
    .label("Mean Hs")
    .legend(|(x, y)| Rectangle::new([(x, y), (x + 10, y + 10)], BLUE.filled()));
    
    // 90th percentile
    chart.draw_series(
        seasons.iter().map(|(name, stats)| {
            let p90 = stats.percentiles.get(&90).unwrap_or(&0.0);
            Circle::new((*name, *p90), 5, RED.filled())
        })
    )?
    .label("90th percentile")
    .legend(|(x, y)| Circle::new((x + 5, y + 5), 5, RED.filled()));
    
    // Maximum
    chart.draw_series(
        seasons.iter().map(|(name, stats)| {
            PathElement::new(vec![(*name, stats.max_hs)], GREEN.stroke_width(2))
        })
    )?
    .label("Maximum")
    .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 10, y)], GREEN));
    
    chart.configure_series_labels()
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()?;
    
    root.present()?;
    Ok(())
}
```

### Part 6: Integration with Real Data

Connect to Ocean Networks Canada for BC wave data:

```rust
// In src/data_fetcher.rs
use reqwest;
use chrono::{DateTime, Duration, Utc};
use serde_json::Value;
use crate::wave_climate::WaveObservation;

pub struct OncDataFetcher {
    api_token: String,
    base_url: String,
}

impl OncDataFetcher {
    pub fn new(api_token: String) -> Self {
        OncDataFetcher {
            api_token,
            base_url: "https://data.oceannetworks.ca/api".to_string(),
        }
    }
    
    /// Fetch wave data for a specific location and time range
    pub async fn fetch_wave_data(
        &self,
        location_code: &str,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Result<Vec<WaveObservation>, Box<dyn std::error::Error>> {
        let url = format!(
            "{}/scalardata/location/{}/devicecategory/WAVEMONITOR",
            self.base_url, location_code
        );
        
        let params = [
            ("token", &self.api_token),
            ("dateFrom", &start.format("%Y-%m-%dT%H:%M:%S.000Z").to_string()),
            ("dateTo", &end.format("%Y-%m-%dT%H:%M:%S.000Z").to_string()),
        ];
        
        let response = reqwest::Client::new()
            .get(&url)
            .query(&params)
            .send()
            .await?
            .json::<Value>()
            .await?;
        
        // Parse response into observations
        let mut observations = Vec::new();
        
        if let Some(data) = response["data"].as_array() {
            for record in data {
                if let (Some(timestamp), Some(hs), Some(tp), Some(dp)) = (
                    record["time"].as_str(),
                    record["significantWaveHeight"].as_f64(),
                    record["peakPeriod"].as_f64(),
                    record["peakDirection"].as_f64(),
                ) {
                    let timestamp = DateTime::parse_from_rfc3339(timestamp)?
                        .with_timezone(&Utc);
                    
                    observations.push(WaveObservation {
                        timestamp,
                        hs,
                        tp,
                        tm: record["meanPeriod"].as_f64().unwrap_or(tp * 0.8),
                        dp,
                        dm: record["meanDirection"].as_f64().unwrap_or(dp),
                        spread: record["directionalSpread"].as_f64().unwrap_or(30.0),
                        wind_speed: record["windSpeed"].as_f64(),
                        wind_dir: record["windDirection"].as_f64(),
                    });
                }
            }
        }
        
        Ok(observations)
    }
}
```

### Part 7: Main Application

Bring it all together in a comprehensive analysis:

```rust
// In src/main.rs
mod wave_climate;
mod extreme_analysis;
mod visualization;
mod data_fetcher;

use chrono::{DateTime, Duration, Utc};
use wave_climate::{WaveClimateAnalyzer, WaveObservation};
use std::error::Error;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    println!("Coastal Dynamics Tutorial 4.1: Wave Climate Analysis");
    println!("===================================================\n");
    
    // Initialize analyzer for Tofino (west coast Vancouver Island)
    let mut analyzer = WaveClimateAnalyzer::new(
        "Tofino, BC".to_string(),
        4.0,  // Storm threshold: 4m
        0.5,  // Calm threshold: 0.5m
    );
    
    // Generate synthetic data representing BC coast climate
    let observations = generate_bc_wave_climate(365 * 5);  // 5 years
    analyzer.add_observations(observations);
    
    // Perform analyses
    println!("Analyzing {} observations...\n", analyzer.observations.len());
    
    // 1. Seasonal analysis
    let seasonal = analyzer.seasonal_analysis();
    println!("Seasonal Wave Climate:");
    println!("Winter: mean Hs = {:.2}m, max = {:.2}m, storms = {}",
        seasonal.winter.mean_hs, seasonal.winter.max_hs, seasonal.winter.storm_count);
    println!("Summer: mean Hs = {:.2}m, max = {:.2}m, storms = {}",
        seasonal.summer.mean_hs, seasonal.summer.max_hs, seasonal.summer.storm_count);
    println!("Seasonal variation factor: {:.2}\n",
        seasonal.winter.mean_hs / seasonal.summer.mean_hs);
    
    // 2. Wave systems classification
    let (swell, wind_sea) = analyzer.classify_wave_systems();
    println!("Wave Systems:");
    println!("Swell: {:.1}% of observations", 
        swell.len() as f64 / analyzer.observations.len() as f64 * 100.0);
    println!("Wind sea: {:.1}% of observations\n",
        wind_sea.len() as f64 / analyzer.observations.len() as f64 * 100.0);
    
    // 3. Directional analysis
    let wave_rose = analyzer.wave_rose(16);
    println!("Dominant Wave Direction: {:.0}°", 
        wave_rose.iter()
            .max_by(|a, b| a.energy_fraction.partial_cmp(&b.energy_fraction).unwrap())
            .unwrap().direction);
    
    // 4. Extreme value analysis
    let eva = perform_extreme_analysis(&analyzer);
    println!("\nExtreme Value Analysis:");
    println!("50-year return value: {:.2}m", eva.return_50);
    println!("100-year return value: {:.2}m", eva.return_100);
    
    // 5. Generate visualizations
    visualization::plot_wave_rose(&wave_rose, "wave_rose_bc.png", "BC Coast Wave Rose")?;
    visualization::plot_seasonal_comparison(&analyzer, "seasonal_bc.png")?;
    
    // Environmental and social considerations
    println!("\nEnvironmental Context:");
    println!("- Winter storms drive sediment transport and beach morphology changes");
    println!("- Summer calm periods allow kelp forest recovery and growth");
    println!("- Wave exposure determines intertidal species distribution");
    println!("- Traditional harvesting windows align with seasonal wave patterns");
    println!("- Climate change may intensify winter storms and alter wave directions");
    
    Ok(())
}

/// Generate synthetic wave data representative of BC coast
fn generate_bc_wave_climate(days: usize) -> Vec<WaveObservation> {
    use rand::{thread_rng, Rng};
    use rand_distr::{Normal, Distribution};
    use chrono::TimeZone;
    
    let mut rng = thread_rng();
    let mut observations = Vec::new();
    let start_date = Utc.ymd(2019, 1, 1).and_hms(0, 0, 0);
    
    for day in 0..days {
        let date = start_date + Duration::days(day as i64);
        let day_of_year = date.ordinal();
        
        // Seasonal variation (stronger in winter)
        let seasonal_factor = 1.0 + 0.8 * (2.0 * std::f64::consts::PI * 
            (day_of_year as f64 - 80.0) / 365.0).cos();
        
        // Generate 8 observations per day (3-hour intervals)
        for hour in (0..24).step_by(3) {
            let timestamp = date + Duration::hours(hour as i64);
            
            // Base conditions with seasonal variation
            let base_hs = 1.5 * seasonal_factor;
            let hs_dist = Normal::new(base_hs, 0.5 * seasonal_factor).unwrap();
            let hs = hs_dist.sample(&mut rng).max(0.1);
            
            // Period correlates with height
            let tp = 8.0 + 2.0 * hs.sqrt() + rng.gen::<f64>() * 2.0;
            let tm = tp * (0.7 + rng.gen::<f64>() * 0.2);
            
            // Direction: mainly from W-NW (270-315°) with some spread
            let dp = 292.5 + Normal::new(0.0, 20.0).unwrap().sample(&mut rng);
            let dm = dp + Normal::new(0.0, 5.0).unwrap().sample(&mut rng);
            
            // Wind correlation
            let wind_speed = Some(5.0 + 3.0 * hs + rng.gen::<f64>() * 5.0);
            let wind_dir = Some(dp + Normal::new(-10.0, 15.0).unwrap().sample(&mut rng));
            
            observations.push(WaveObservation {
                timestamp,
                hs,
                tp,
                tm,
                dp: dp % 360.0,
                dm: dm % 360.0,
                spread: 25.0 + rng.gen::<f64>() * 10.0,
                wind_speed,
                wind_dir,
            });
        }
    }
    
    observations
}

struct ExtremeAnalysisResults {
    return_50: f64,
    return_100: f64,
}

fn perform_extreme_analysis(analyzer: &WaveClimateAnalyzer) -> ExtremeAnalysisResults {
    // Extract annual maxima
    use std::collections::HashMap;
    let mut annual_maxima: HashMap<i32, f64> = HashMap::new();
    
    for obs in &analyzer.observations {
        let year = obs.timestamp.year();
        let entry = annual_maxima.entry(year).or_insert(0.0);
        if obs.hs > *entry {
            *entry = obs.hs;
        }
    }
    
    let maxima: Vec<f64> = annual_maxima.values().cloned().collect();
    
    // Simple Gumbel fit (assuming GEV shape parameter ≈ 0)
    let mean = maxima.iter().sum::<f64>() / maxima.len() as f64;
    let variance = maxima.iter()
        .map(|x| (x - mean).powi(2))
        .sum::<f64>() / maxima.len() as f64;
    let std = variance.sqrt();
    
    let scale = std * (6.0_f64).sqrt() / std::f64::consts::PI;
    let location = mean - 0.5772 * scale;  // Euler's constant
    
    // Return values using Gumbel distribution
    let return_50 = location - scale * (-(50.0_f64.ln())).ln();
    let return_100 = location - scale * (-(100.0_f64.ln())).ln();
    
    ExtremeAnalysisResults { return_50, return_100 }
}
```

### Exercises

#### Exercise 1: Storm Tracking
Implement a storm identification and tracking algorithm:

```rust
pub struct Storm {
    pub start: DateTime<Utc>,
    pub peak: DateTime<Utc>,
    pub end: DateTime<Utc>,
    pub max_hs: f64,
    pub total_energy: f64,
    pub duration_hours: f64,
}

impl WaveClimateAnalyzer {
    pub fn identify_storms(&self, hs_threshold: f64, min_duration: Duration) -> Vec<Storm> {
        // TODO: Implement storm identification
        // - Find periods where Hs > threshold
        // - Require minimum duration
        // - Track peak and total energy
    }
}
```

#### Exercise 2: Wave Power Assessment
Calculate wave power potential for marine renewable energy:

```rust
pub fn wave_power_resource(&self) -> WavePowerStats {
    // Wave power: P = (ρg²/64π) * Hs² * Tp
    // TODO: Calculate mean and seasonal wave power
    // Consider capacity factor and device limitations
}
```

#### Exercise 3: Climate Change Impact
Analyze trends in wave climate over time:

```rust
pub fn trend_analysis(&self) -> TrendResults {
    // TODO: Implement Mann-Kendall test for trends
    // Analyze changes in:
    // - Mean and extreme Hs
    // - Storm frequency
    // - Wave direction
    // - Seasonal patterns
}
```

#### Exercise 4: Coastal Impact Assessment
Link wave climate to coastal processes:

```rust
pub fn coastal_impact_analysis(&self) -> CoastalImpacts {
    // TODO: Calculate:
    // - Longshore energy flux
    // - Cross-shore storm impact parameter
    // - Morphological diffusivity
    // - Habitat exposure index
}
```

### Questions for Reflection

1. **Climate Variability**: How do El Niño/La Niña cycles affect BC wave climate? What are the implications for coastal management?

2. **Indigenous Knowledge**: How does scientific wave climate analysis complement traditional Indigenous knowledge of seasonal ocean conditions?

3. **Engineering Design**: For a proposed wave energy converter, what aspects of wave climate are most critical? How would you optimize device placement?

4. **Climate Adaptation**: Given projected changes in North Pacific storm tracks, how might BC coastal communities need to adapt?

5. **Ecological Connections**: How does wave climate variability affect kelp forest dynamics and the species that depend on them?

### Additional Resources

- Ocean Networks Canada data portal
- NOAA WaveWatch III hindcast data
- Environment Canada Marine Weather Services
- Pacific Climate Impacts Consortium reports
- First Nations coastal knowledge studies

### Next Tutorial Preview

In Tutorial 4.2, we'll dive deeper into extreme value statistics, implementing sophisticated methods for estimating design conditions and understanding uncertainty in extreme wave predictions.

Remember: Wave climate shapes not just our coastlines, but the communities and ecosystems that depend on them. Understanding these patterns is key to sustainable coastal stewardship.
